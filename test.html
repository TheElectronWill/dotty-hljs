<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Test HLJS</title>
  <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.2/build/styles/lightfair.min.css"> -->
  <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.2/build/styles/atom-one-light.min.css"> -->
  <link rel="stylesheet" href="./nord-light.css">
  <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.2/build/highlight.min.js"></script>
  <script src="./scala3.js"></script>
  <style>
    pre code {
      font-family: "Fira Code", monospace;
      font-size: 14px;
      font-variant-ligatures: none;
    }
  </style>
</head>
<body>
  <pre><code class="language-dotty">
    /** Testing hljs.
     * Here is some java (ok if not highlighted):
     * ```java
     * interface X extends Y
     * ```
     * test *italic* and **bold**, _italic_ and __bold__
     * link test: [link](https://scala-lang.org)
     * list test:
     * - 1
     * - 2
     * - 3
     * @param x some parameter x
     * @param y some parameter y
     */
    open class Test[+X, -Y <: Self[XX, YY, ?]] private(x: Int, y: Int)(z: 0, l: "a" = "a") extends Coords(x,y) with T[X:::Y](z) derives Eql {
      inline def toto[T](inline xs: Buffer[Seq[T]] = null)(using Context[?]): R[?] =
        var neg = -3000
        var as = 123_456L
        val end = s"interpolation of some $things: ${toto(0)}"
        val float = .56e-17d
        val open = true
        val f = (A, B) => Unit
        xs += Nil
        xs ++= Nil
        assert((open+1).isInstanceOf[Boolean])
        assertFail(open.asInstanceOf[java.lang.Boolean].nn.toString)
        val isA = (xs == A)
        val isntB = (xs != B)
        ???

      transparent inline def x() = ???
      inline override transparent protected def x() = ???
      sealed trait ST
      final class A extends ST
      open abstract implicit private class B
      opaque private type T = TheType

      protected type Z <: String >: String
    }
    enum Letter {
      case A, B, C
      case D(param: Int)
    }
    enum Color(private val rgb: Int):
      case Red   extends Color(0xFF0000)
      case Green extends Color(0x00FF00)
      case Blue  extends Color(0x0000FF)

    @volatile final val zero = 0
    lazy val x: Option[AnyRef] = Some("test")

    override protected[mypackage] def f = super.g(Nil)

    x match
      case None => throw new Exception("!")
      case List(Some("test")) => ...
      case Some(s: String) => println(s)
      case l: Letter => return
      case black @ Color(0) => ...
      case (a :+ b) :: c :: Some(z) => _
      case _ =>
        if 1 > 2 then
          while false do
            for x <- xs
                y <- ys
            yield (x,y)
          end while
        else if 1 < 2 ()
        else "yay!"

    trait Seq[A] extends Iterable[A] with T1 with T2[T1,A]:
      @infix @alpha("prepended")
      def ::(x: A) = ???

      @alpha("append")
      def +=(x: A) =
        ???
      end `+=`

      private var _f: A => Boolean = ()=>false
      override def func_=(f: A => Boolean) = _f = f

    type Concat[Xs <: Tuple, +Ys <: Tuple] <: Tuple = Xs match {
      case Unit => Ys
      case x *: xs => x *: Concat[xs, Ys]
    }
    opaque type TL1 = [T] =>> R1

    given intOrd = ...
    given intOrd as Ord[Int] = ...
    given listOrd[T](using ord: Ord[T]) as Ord[List[T]] {...}
    given stringToToken as Conversion[String, Token] = KeyWord(_)

    val ord = summon[Ord[Int]]
    using.sort(this)(using ord)// the first 'using' is not a keyword

    trait SemiGroup[T]:
      extension (x: T) def combine (y: T): T

    extension [T: Numeric](x: T)
      @infix def min(y: T): T = ...
  </code></pre>
  <br>
  <pre><code class="language-dotty">
    package a.b.c.ddd

    /**
     * A person has a name and an age.
     */
    case class Person(name: String, age: Int)

    trait Long[Aaaa,Bbbb,Cccc] extends SomeParentType
      with Abcdefg with ThisNameIsWayTooLongToBeAllowedInRealSourceCode
      derives AwesomeTypeclass
    trait Other
    open class A
    final class B
    package object library
    def multipleParamLists[T, U >: T, V <: T](x: T)
                                             (y: U, z: V)
                                             (using x: String): ReturnType[Int => ?]
    object PO:
      def apply() = "PO"

    def absoluteValue(n: Int): Int =
      if (n < 0) -n else n

    def interp(n: Int): String =
      s"there are $n ${color} balloons.\n"
      f(0, s"interp $var ${f(0, "x")}.")

    type ξ[A] = (A, A)

    trait Hist { lhs =>
      def ⊕(rhs: Hist): Hist
      def €(amount: Int): Int
    }

    def gsum[A: Ring](as: Seq[A]): A =
      as.foldLeft(Ring[A].zero)(_ + _)

    trait Cake {
      type T;
      type Q
      val things: Seq[T]
      val nested: (a: A, b: (C,D) => E) => A[B[A[B[C[D],E]]]]

      abstract class Spindler

      def spindle(s: Spindler, ts: Seq[T], reversed: Boolean = false): Seq[Q]
    }

    val colors = Map(
      "red"       -> 0xFF0000,
      "turquoise" -> 0x00FFFF,
      "black"     -> 0x000000,
      "orange"    -> 0xFF8040,
      "brown"     -> 0x804000)

    lazy val ns = for {
      x <- 0 until 100
      y <- 0 until 100
    } yield (x + y) * 33.33

    /* Testing comments now */
    // This is a one-line comment
    val x: String// Comment
    val x: String/* Comment */
    val x //: String
    def f(y: Int): A // Comment
    def f(y: Int): A /* Comment */
    def f // comment
    def f[/* comment */]
    def f(y: /* comment */)

    class A  // Comment
    {}
    class A /* Comment */
    {}
    class A: // Comment
    class A /* Comment */

    class C extends Parent // ok
    class C extends Parent /* ok */
    class C extends Parent with Trait // ok
    class C extends Parent with Trait /* ok */
    class C extends Parent with // Trait
    class C extends Parent with /* Trait */
    class C derives Typeclass // ok
    class C derives Typeclass /* ok */
    class C derives // Typeclass
    class C derives /* Typeclass */
    class C[s <: String] // ok
    class C[s <: String] /* ok */
    class C(s: String) // ok
    class C(s: String) /* ok */

    enum X/*_*/[+T/*a*/<:/*b*/U]/*hello*/(/*hi*/s:/*hey*/String/*there*/)://test
      case Red extends Color(/*0xFF0000*/)
      case Red extends // Color(0xFF0000)
      case Red extends /* Color(0xFF0000) */
      case Red extends Color(0xFF0000) // comment
      case Red extends Color(0xFF0000) /* comment */
      case // Red extends Color(0xFF0000) // comment
      case /* Red extends Color(0xFF0000) /* comment*/

    type // X = Z
    case // x: String
    case // A,B,C
    enum // Z extends T with U derives V
    given x // as T
    def /= //(v: Int): Int

    def f[T, U](x: T)(using y: U, z: V)(using C1[T], C2[T], C3[U]): R[T] => Z[U]

    def f(x: Int): ExecutionContext ?=> Int = ???
    def f(using x: Int): ExecutionContext =>> Int = ???
    def f(inline x: Int): ExecutionContext => Int = ???

    def table(init: Table ?=> Unit) = ???
    def table(init: Table =>> Unit) = ???
    def table(init: Table => Unit) = ???

    g(A => f(3))
    g(ExecutionContext ?=> f(3))  // is expanded to g((using ev: ExecutionContext) => f(3)(using ev))
    g((using ctx: ExecutionContext) => f(22)(using ctx)) // is left as it is

    @java.lang.Deprecated("A")
    class A(val x: Int) // The type for which we want an `Ordering`

    // Convert `A` to a type for which an `Ordering` is available:
    implicit val AToInt: Conversion[A, Int] = _.x

    implicitly[Ordering[Int]] // ...
    implicitly[Ordering[A]] // ...
                            // ...
  </code></pre>
  <pre><code class="language-dotty">
    given ec as ExecutionContext = ...

    def f(x: Int): ExecutionContext ?=> Int = ...

    // could be written as follows with the type alias from above
    // def f(x: Int): Executable[Int] = ...

    f(2)(using ec)   // explicit argument
    f(2)             // argument is inferred

    inline def summonAll[T <: Tuple]: List[Eq[_]] = inline erasedValue[T] match {
      case _: EmptyTuple => Nil
      case _: (t *: ts) => summonInline[Eq[t]] :: summonAll[ts]
    }

    val both: Object & Product
    val both: a & b & c

    val either: Password | UserName
    val either: a | b | c

    def f(union: AAA | BBB | CC, intersection: AAA & BBB & CC)
    def f(union: a | b | c, intersection: a & b & c)

    type function = x => (B | C <: D)

    // --- Macros, splices, quotations ---

    ${'{e}} = e
    '{${e}} = e
    ${'[T]} = T
    '[${T}] = T

    def to[T: Type, R: Type](f: Expr[T] => Expr[R])(using QuoteContext): Expr[T => R] =
      '{ (x: T) => ${ f('x) } }

    def from[T: Type, R: Type](f: Expr[T => R])(using QuoteContext): Expr[T] => Expr[R] =
      (x: Expr[T]) => '{ $f($x) }

    import scala.quoted._

    def compile(e: Exp, env: Map[String, Expr[Int]])(using QuoteContext): Expr[Int] = e match {
      case Num(n) =>
        Expr(n)
      case Plus(e1, e2) =>
        '{ ${ compile(e1, env) } + ${ compile(e2, env) } }
      case Var(x) =>
        env(x)
      case Let(x, e, body) =>
        '{ val y = ${ compile(e, env) }; ${ compile(body, env + (x -> 'y)) } }
    }
  </code></pre>
  <pre><code class="language-java">
    // This is Java, for comparison
    package a.b.c.ddd;

    @annot("x", null)
    public class Test&lt;X&lt;Y&gt;&gt; extends A implements B, C, D {
      static final int x = 0;

      /**
       * Some function.
       * @param a parameter
       * @return nothing
       */
      public void x(int a) {
        return x == y && a > 0 || b != this;
        throw new AbcdError(0, false);
      }
    }
  </code></pre>
  <script>
    hljs.registerLanguage('dotty', highlightDotty);
    hljs.initHighlightingOnLoad();
  </script>
</body>
</html>
